import speech_recognition as sr
from gtts import gTTS
from playsound import playsound
import tempfile
import os
import requests
from requests.adapters import HTTPAdapter, Retry
import time
import threading
import logging
from typing import Optional, Dict, Any
import json
import uuid
import functools
import weakref

# ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

def load_webhook_url() -> str:
    """‡πÇ‡∏´‡∏•‡∏î Webhook URL ‡∏à‡∏≤‡∏Å environment variable ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏ü‡∏•‡πå .env"""
    url = os.environ.get("WEBHOOK_URL_VOICE")
    if url:
        return url
    # ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö .env ‡πÅ‡∏ö‡∏ö‡∏á‡πà‡∏≤‡∏¢
    env_path = os.path.join(os.path.dirname(__file__), ".env")
    if os.path.exists(env_path):
        with open(env_path, encoding="utf-8") as f:
            for line in f:
                if line.strip().startswith("WEBHOOK_URL_VOICE="):
                    return line.strip().split("=", 1)[1]
    # fallback: ‡πÉ‡∏ä‡πâ‡∏Ñ‡πà‡∏≤ default (‡∏ñ‡πâ‡∏≤‡∏°‡∏µ)
    return "https://a611-27-55-89-186.ngrok-free.app/webhook/dd446900-af8a-4726-abc6-033a0db60b10"

class VoiceAssistant:
    def __init__(self, webhook_url: str):
        self.webhook_url = webhook_url
        self.activated = False
        self.recognizer = sr.Recognizer()
        self.microphone = sr.Microphone()
        self.session = requests.Session()  # ‡πÉ‡∏ä‡πâ session ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡∏£‡∏∞‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡∏†‡∏≤‡∏û‡∏ó‡∏µ‡πà‡∏î‡∏µ‡∏Ç‡∏∂‡πâ‡∏ô
        self.temp_files = []  # ‡πÄ‡∏Å‡πá‡∏ö‡πÑ‡∏ü‡∏•‡πå temp ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏•‡∏ö‡πÉ‡∏ô‡∏†‡∏≤‡∏¢‡∏´‡∏•‡∏±‡∏á
        self.session_id = str(uuid.uuid4())  # ‡∏™‡∏£‡πâ‡∏≤‡∏á unique session ID
        
        # ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ session ‡πÅ‡∏•‡∏∞ retry mechanism
        retries = Retry(total=3, backoff_factor=0.1, status_forcelist=[500, 502, 503, 504])
        self.session.mount('http://', HTTPAdapter(max_retries=retries))
        self.session.mount('https://', HTTPAdapter(max_retries=retries))
        
        # Cache ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏ó‡∏µ‡πà‡πÅ‡∏õ‡∏•‡∏á‡πÅ‡∏•‡πâ‡∏ß
        self._speech_cache = {}  # ‡πÉ‡∏ä‡πâ dict ‡∏õ‡∏Å‡∏ï‡∏¥‡πÅ‡∏ó‡∏ô weakref
        
        # ‡πÉ‡∏ä‡πâ threading.Lock ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö thread safety
        self._lock = threading.Lock()
        
        # ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ microphone
        self._setup_microphone()
        
        # ‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°
        self.control_phrases = {
            "activate": ["‡∏™‡∏ß‡∏±‡∏™‡∏î‡∏µ‡∏ö‡∏≠‡∏ó", "‡πÄ‡∏Æ‡∏•‡πÇ‡∏•‡πà‡∏ö‡∏≠‡∏ó", "‡∏ö‡∏≠‡∏ó‡∏ü‡∏±‡∏á"],
            "deactivate": ["‡∏õ‡∏¥‡∏î‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô", "‡∏´‡∏¢‡∏∏‡∏î‡∏ü‡∏±‡∏á", "‡∏ö‡∏≠‡∏ó‡∏´‡∏¢‡∏∏‡∏î"],
            "exit": ["‡∏õ‡∏¥‡∏î‡∏£‡∏∞‡∏ö‡∏ö", "‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏£‡∏∞‡∏ö‡∏ö", "‡∏ö‡∏≤‡∏¢‡∏ö‡∏≠‡∏ó"]
        }
        
    def _setup_microphone(self):
        """‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡πÑ‡∏°‡πÇ‡∏Ñ‡∏£‡πÇ‡∏ü‡∏ô"""
        try:
            with self.microphone as source:
                logger.info("üéôÔ∏è ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏õ‡∏£‡∏±‡∏ö‡∏ï‡∏±‡πâ‡∏á‡πÑ‡∏°‡πÇ‡∏Ñ‡∏£‡πÇ‡∏ü‡∏ô...")
                self.recognizer.adjust_for_ambient_noise(source, duration=1)
                logger.info("‚úÖ ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡πÑ‡∏°‡πÇ‡∏Ñ‡∏£‡πÇ‡∏ü‡∏ô‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô")
        except Exception as e:
            logger.error(f"‚ùå ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡πÑ‡∏°‡πÇ‡∏Ñ‡∏£‡πÇ‡∏ü‡∏ô‡πÑ‡∏î‡πâ: {e}")
            
    @functools.lru_cache(maxsize=128)
    def _generate_speech_file(self, text: str, lang: str) -> str:
        """‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏ü‡∏•‡πå‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡πÅ‡∏ö‡∏ö cache"""
        tts = gTTS(text=text, lang=lang, slow=False)
        with tempfile.NamedTemporaryFile(delete=False, suffix=".mp3") as fp:
            temp_filename = fp.name
            tts.save(temp_filename)
            return temp_filename

    def speak(self, text: str, lang: str = 'th') -> bool:
        """‡πÅ‡∏õ‡∏•‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏û‡∏π‡∏î"""
        try:
            print(f"üó£Ô∏è BOT: {text}")
            logger.info(f"Speaking: {text}")
            
            # ‡πÉ‡∏ä‡πâ cache ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏î‡∏¥‡∏°
            cache_key = f"{text}_{lang}"
            temp_filename = self._speech_cache.get(cache_key)
            
            if not temp_filename or not os.path.exists(temp_filename):
                temp_filename = self._generate_speech_file(text, lang)
                self._speech_cache[cache_key] = temp_filename
                self.temp_files.append(temp_filename)
            
            playsound(temp_filename)
            return True
            
        except Exception as e:
            logger.error(f"‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏û‡∏π‡∏î: {e}")
            return False

    def _cleanup_temp_file(self, filename: str):
        """‡∏•‡∏ö‡πÑ‡∏ü‡∏•‡πå temp ‡πÅ‡∏ö‡∏ö‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢"""
        try:
            with self._lock:
                if os.path.exists(filename):
                    os.remove(filename)
                    if filename in self.temp_files:
                        self.temp_files.remove(filename)
        except Exception as e:
            logger.error(f"‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏•‡∏ö‡πÑ‡∏ü‡∏•‡πå temp: {e}")

    def listen(self, timeout: int = 5, phrase_time_limit: int = 10, max_retry: int = 2) -> str:
        """‡∏ü‡∏±‡∏á‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡πÅ‡∏•‡∏∞‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏° ‡∏û‡∏£‡πâ‡∏≠‡∏° retry ‡πÅ‡∏•‡∏∞‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞"""
        already_prompted = False
        for attempt in range(max_retry + 1):
            try:
                with self.microphone as source:
                    if not self.activated:
                        print("üïì ‡∏£‡∏≠‡∏ü‡∏±‡∏á‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô...")
                        if not already_prompted:
                            self.speak("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏û‡∏π‡∏î‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô", lang="th")
                            already_prompted = True
                    else:
                        print("üé§ ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ü‡∏±‡∏á...")
                        if not already_prompted:
                            self.speak("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏û‡∏π‡∏î‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì", lang="th")
                            already_prompted = True
                    audio = self.recognizer.listen(
                        source,
                        timeout=timeout,
                        phrase_time_limit=phrase_time_limit
                    )
                # ‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°
                text = self.recognizer.recognize_google(audio, language='th-TH')
                logger.info(f"Recognized: {text}")
                print(f"üë§ YOU: {text}")
                return text.strip().lower()
            except sr.WaitTimeoutError:
                logger.info("‚è≥ ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏¢‡∏¥‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏û‡∏π‡∏î‡πÉ‡∏ô‡πÄ‡∏ß‡∏•‡∏≤‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î")
                if attempt == max_retry:
                    if self.activated:
                        self.speak("‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏¢‡∏¥‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏û‡∏π‡∏î‡πÉ‡∏´‡∏°‡πà‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á", lang="th")
                continue
            except sr.UnknownValueError:
                logger.info("üòï ‡πÑ‡∏°‡πà‡πÄ‡∏Ç‡πâ‡∏≤‡πÉ‡∏à‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏û‡∏π‡∏î")
                if attempt == max_retry:
                    self.speak("‡∏Ç‡∏≠‡∏≠‡∏†‡∏±‡∏¢ ‡πÑ‡∏°‡πà‡πÄ‡∏Ç‡πâ‡∏≤‡πÉ‡∏à‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏û‡∏π‡∏î ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏û‡∏π‡∏î‡πÉ‡∏´‡∏°‡πà‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á", lang="th")
                continue
            except sr.RequestError as e:
                logger.error(f"üö® ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏ö‡∏£‡∏¥‡∏Å‡∏≤‡∏£: {e}")
                self.speak("‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏ö‡∏£‡∏¥‡∏Å‡∏≤‡∏£‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏™‡∏µ‡∏¢‡∏á ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏≠‡∏¥‡∏ô‡πÄ‡∏ó‡∏≠‡∏£‡πå‡πÄ‡∏ô‡πá‡∏ï", lang="th")
                return ""
            except Exception as e:
                logger.error(f"‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ü‡∏±‡∏á: {e}")
                if attempt == max_retry:
                    self.speak("‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ü‡∏±‡∏á ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà", lang="th")
                continue
        return ""

    def send_to_ai(self, text: str, timeout: int = 30) -> str:
        """‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÑ‡∏õ‡∏¢‡∏±‡∏á AI ‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏£‡∏≠‡πÅ‡∏•‡∏∞‡∏ï‡∏±‡∏î‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ß‡πà‡∏≤‡∏á"""
        text = text.strip()
        if not text:
            return "‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏° ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏û‡∏π‡∏î‡πÉ‡∏´‡∏°‡πà‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á"
        try:
            self.speak("‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏• ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏£‡∏≠‡∏™‡∏±‡∏Å‡∏Ñ‡∏£‡∏π‡πà...", lang="th")
            payload = {
                "text": text,
                "session_id": self.session_id,
                "timestamp": time.time(),
                "language": "th"
            }
            headers = {
                'Content-Type': 'application/json',
                'User-Agent': 'VoiceAssistant/1.0',
                'Connection': 'keep-alive'
            }
            with self._lock:
                response = self.session.post(
                    self.webhook_url,
                    json=payload,
                    headers=headers,
                    timeout=timeout
                )
                response.raise_for_status()
            result = response.json()
            logger.info(f"AI Response: {result}")
            # ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏´‡∏•‡∏≤‡∏¢‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö response
            if isinstance(result, dict):
                for key in ("reply", "response", "message", "text"):
                    if key in result and result[key]:
                        return str(result[key]).strip()
                return str(result)
            elif isinstance(result, str):
                return result.strip()
            else:
                return "‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡πÑ‡∏î‡πâ‡∏Å‡∏•‡∏±‡∏ö‡∏°‡∏≤"
        except requests.exceptions.Timeout:
            logger.error("AI request timeout")
            return "‡∏Ç‡∏≠‡∏≠‡∏†‡∏±‡∏¢ ‡∏£‡∏∞‡∏ö‡∏ö‡πÉ‡∏ä‡πâ‡πÄ‡∏ß‡∏•‡∏≤‡∏ô‡∏≤‡∏ô‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á"
        except requests.exceptions.ConnectionError:
            logger.error("AI connection error")
            return "‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ö‡∏£‡∏∞‡∏ö‡∏ö‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÑ‡∏î‡πâ ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠"
        except requests.exceptions.HTTPError as e:
            logger.error(f"HTTP Error: {e}")
            return f"‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡∏à‡∏≤‡∏Å‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå: {e}"
        except Exception as e:
            logger.error(f"‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡∏Ç‡∏ì‡∏∞‡∏ï‡∏¥‡∏î‡∏ï‡πà‡∏≠ AI: {e}")
            return "‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ö‡∏£‡∏∞‡∏ö‡∏ö‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•"

    def check_control_phrases(self, text: str) -> Optional[str]:
        """‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡πÅ‡∏ö‡∏ö‡∏¢‡∏∑‡∏î‡∏´‡∏¢‡∏∏‡πà‡∏ô"""
        text_lower = text.lower()
        for action, phrases in self.control_phrases.items():
            for phrase in phrases:
                if phrase.lower() in text_lower:
                    return action
        return None
    
    def cleanup(self):
        """‡∏ó‡∏≥‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏∞‡∏≠‡∏≤‡∏î‡∏ó‡∏£‡∏±‡∏û‡∏¢‡∏≤‡∏Å‡∏£‡πÅ‡∏ö‡∏ö‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢"""
        logger.info("‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ó‡∏≥‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏∞‡∏≠‡∏≤‡∏î‡∏ó‡∏£‡∏±‡∏û‡∏¢‡∏≤‡∏Å‡∏£...")
        
        # ‡∏•‡πâ‡∏≤‡∏á cache
        self._speech_cache.clear()
        self._generate_speech_file.cache_clear()
        
        with self._lock:
            # ‡∏õ‡∏¥‡∏î session
            self.session.close()
            
            # ‡∏•‡∏ö‡πÑ‡∏ü‡∏•‡πå temp ‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏•‡∏∑‡∏≠
            for temp_file in list(self.temp_files):  # ‡πÉ‡∏ä‡πâ list copy ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô race condition
                try:
                    if os.path.exists(temp_file):
                        os.remove(temp_file)
                        self.temp_files.remove(temp_file)
                except Exception as e:
                    logger.error(f"‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏•‡∏ö‡πÑ‡∏ü‡∏•‡πå temp: {e}")
        
        logger.info("‡∏ó‡∏≥‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏∞‡∏≠‡∏≤‡∏î‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô")
    
    def run(self):
        """‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö"""
        logger.info("üöÄ ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö Voice Assistant")
        logger.info(f"üÜî Session ID: {self.session_id}")
        self.speak("‡∏™‡∏ß‡∏±‡∏™‡∏î‡∏µ‡∏Ñ‡πà‡∏∞ ‡∏£‡∏∞‡∏ö‡∏ö‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏ó‡∏≥‡∏á‡∏≤‡∏ô ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏û‡∏π‡∏î '‡∏™‡∏ß‡∏±‡∏™‡∏î‡∏µ‡∏ö‡∏≠‡∏ó' ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô")
        consecutive_errors = 0
        max_consecutive_errors = 5
        try:
            while True:
                text = self.listen()
                if not text:
                    consecutive_errors += 1
                    if consecutive_errors >= max_consecutive_errors:
                        logger.warning("‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡∏ï‡πà‡∏≠‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡∏£‡∏∞‡∏ö‡∏ö...")
                        self._setup_microphone()
                        consecutive_errors = 0
                    continue
                consecutive_errors = 0  # ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡∏ï‡∏±‡∏ß‡∏ô‡∏±‡∏ö‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏ü‡∏±‡∏á‡πÑ‡∏î‡πâ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à
                # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°
                control_action = self.check_control_phrases(text)
                if control_action == "activate" and not self.activated:
                    self.activated = True
                    self.speak("‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏£‡∏±‡∏ö‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏Ñ‡πà‡∏∞")
                    logger.info("‡∏£‡∏∞‡∏ö‡∏ö‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô")
                elif control_action == "deactivate" and self.activated:
                    self.activated = False
                    self.speak("‡∏£‡∏∞‡∏ö‡∏ö‡∏à‡∏∞‡∏´‡∏¢‡∏∏‡∏î‡∏£‡∏±‡∏ö‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ä‡∏±‡πà‡∏ß‡∏Ñ‡∏£‡∏≤‡∏ß‡∏Ñ‡πà‡∏∞ ‡∏´‡∏≤‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á ‡πÉ‡∏´‡πâ‡∏û‡∏π‡∏î '‡∏™‡∏ß‡∏±‡∏™‡∏î‡∏µ‡∏ö‡∏≠‡∏ó'")
                    logger.info("‡∏£‡∏∞‡∏ö‡∏ö‡∏´‡∏¢‡∏∏‡∏î‡∏ä‡∏±‡πà‡∏ß‡∏Ñ‡∏£‡∏≤‡∏ß")
                elif control_action == "exit":
                    self.speak("‡∏Ç‡∏≠‡∏ö‡∏Ñ‡∏∏‡∏ì‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏Ñ‡πà‡∏∞ ‡∏£‡∏∞‡∏ö‡∏ö‡∏à‡∏∞‡∏õ‡∏¥‡∏î‡∏ï‡∏±‡∏ß‡∏•‡∏á‡πÅ‡∏•‡πâ‡∏ß")
                    logger.info("‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏£‡∏∞‡∏ö‡∏ö")
                    break
                elif self.activated:
                    # ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏õ‡∏Å‡∏ï‡∏¥
                    reply = self.send_to_ai(text)
                    self.speak(reply)
                elif not self.activated:
                    logger.debug("‡∏£‡∏∞‡∏ö‡∏ö‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô")
        except KeyboardInterrupt:
            logger.info("‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì‡∏´‡∏¢‡∏∏‡∏î‡∏à‡∏≤‡∏Å‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ")
            self.speak("‡∏£‡∏∞‡∏ö‡∏ö‡∏à‡∏∞‡∏õ‡∏¥‡∏î‡∏ï‡∏±‡∏ß‡∏•‡∏á‡πÅ‡∏•‡πâ‡∏ß")
        except Exception as e:
            logger.error(f"‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö‡∏´‡∏•‡∏±‡∏Å: {e}")
            self.speak("‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏õ‡∏¥‡∏î‡∏ï‡∏±‡∏ß‡∏•‡∏á")
        finally:
            self.cleanup()

def main():
    """‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏´‡∏•‡∏±‡∏Å"""
    WEBHOOK_URL = load_webhook_url()
    
    # ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÅ‡∏•‡∏∞‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô Voice Assistant
    assistant = VoiceAssistant(WEBHOOK_URL)
    assistant.run()

if __name__ == "__main__":
    main()